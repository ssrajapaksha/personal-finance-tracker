# .cursorrules - Next.js + Supabase Hackathon Team Rules
# Enforces consistency, clarity, and speed for 3-4 person development team

## CORE PRINCIPLES
- Prioritize team consistency over personal preferences
- Keep code simple, readable, and maintainable
- Move fast but don't break things
- Separation of concerns: UI logic separate from business logic

## TYPESCRIPT & CODE STYLE
- Use TypeScript everywhere - no JavaScript files
- Enforce strict typing (strict: true in tsconfig)
- Use functional components with hooks only - NO class components
- Prefer named exports unless default export makes more sense (e.g., page components)
- Use absolute imports from `src/` - never relative imports beyond parent directory
- Use async/await - NEVER use .then() or .catch()
- Follow ESLint + Prettier rules without exception
- Keep files under 200 lines - split into smaller modules if larger

## FOLDER STRUCTURE - STRICTLY ENFORCE
```
src/
├── app/           # Next.js app router (pages, layouts, routes)
├── components/    # Reusable UI components (shadcn/ui based)
├── lib/          # Utilities, Supabase client, helpers, constants
├── hooks/        # Custom React hooks
├── types/        # TypeScript interfaces/types
├── api/          # API abstraction layer - ALL network calls go here
├── tests/        # Unit + integration tests
├── schemas/      # Zod validation schemas
└── styles/       # Global CSS files
```

## API LAYER RULES - CRITICAL
- Components and hooks NEVER directly call Supabase, fetch, or axios
- ALL network/database calls MUST go through functions in `src/api/`
- Each API file exports typed functions that wrap backend calls
- Example structure:
  ```ts
  // src/api/users.ts
  import { supabase } from "@/lib/supabaseClient";
  import { User } from "@/types";
  import { CreateUserSchema } from "@/schemas/user";

  export async function createUser(userData: CreateUserSchema): Promise<User> {
    const { data, error } = await supabase
      .from("users")
      .insert(userData)
      .select()
      .single();
    if (error) throw error;
    return data;
  }
  ```
- This ensures we can replace Supabase later without touching components

## ZOD VALIDATION RULES - NEW
- Use Zod for ALL form validation and API input validation
- Create schemas in `src/schemas/` directory
- Export both the schema and the inferred type
- Example structure:
  ```ts
  // src/schemas/user.ts
  import { z } from "zod";

  export const CreateUserSchema = z.object({
    email: z.string().email(),
    password: z.string().min(8),
    name: z.string().min(2).optional(),
  });

  export type CreateUserRequest = z.infer<typeof CreateUserSchema>;
  ```
- Use schemas in forms with react-hook-form + @hookform/resolvers/zod
- Validate API inputs before sending to backend
- Provide clear error messages for validation failures

## COMPONENT RULES
- Keep components small and focused (single responsibility)
- No business logic in components - use custom hooks for complex state
- Props must be typed with TypeScript interfaces
- Use composition over inheritance
- Example component structure:
  ```tsx
  interface ComponentProps {
    // typed props
  }

  export function ComponentName({ prop }: ComponentProps) {
    // hooks at top
    // event handlers
    // render logic
    return <div>...</div>;
  }
  ```

## SHADCN/UI USAGE
- Always import shadcn components from `@/components/ui/*`
- Use Tailwind classes for custom styling - NO inline styles
- Prefer component composition over rewriting base components
- Example:
  ```tsx
  import { Button } from "@/components/ui/button";
  
  // Good - composition
  <Button className="bg-blue-500 hover:bg-blue-600">Click me</Button>
  
  // Bad - inline styles
  <Button style={{ backgroundColor: 'blue' }}>Click me</Button>
  ```

## SUPABASE & DATABASE
- Direct Supabase client calls ONLY in `src/api/` or `src/lib/`
- Never hardcode API keys - always use process.env
- Use strongly typed Supabase queries with Database types
- Define database types in `src/types/database.ts`
- Example:
  ```ts
  // src/types/database.ts
  export interface Database {
    public: {
      Tables: {
        users: {
          Row: { id: string; email: string; created_at: string };
          Insert: { email: string };
          Update: { email?: string };
        };
      };
    };
  }
  ```

## CUSTOM HOOKS
- Extract reusable logic into custom hooks
- Hooks should be focused and do one thing well
- Always start with "use" prefix
- Return objects with named properties, not arrays
- Example:
  ```tsx
  export function useUsers() {
    const [users, setUsers] = useState<User[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    return { users, loading, error, refetch };
  }
  ```

## TESTING REQUIREMENTS
- Use Jest + React Testing Library
- Tests live in `src/tests/` mirroring the file structure
- Write at least one test for every new component or hook
- Test behavior, not implementation details
- Example test structure:
  ```ts
  // src/tests/components/Button.test.tsx
  import { render, screen } from '@testing-library/react';
  import { Button } from '@/components/Button';

  describe('Button', () => {
    it('renders with correct text', () => {
      render(<Button>Click me</Button>);
      expect(screen.getByText('Click me')).toBeInTheDocument();
    });
  });
  ```

## GIT & COLLABORATION
- Use Conventional Commits format:
  - `feat: add user authentication`
  - `fix: resolve login redirect issue`
  - `chore: update dependencies`
  - `docs: update README setup instructions`
  - `test: add user service tests`
- Branch naming:
  - Feature branches: `feature/user-dashboard`
  - Bug fixes: `fix/login-redirect-bug`
  - Chores: `chore/update-deps`
- PRs must have clear descriptions and reference tasks/issues
- No direct commits to main branch

## CURSOR AI CODE GENERATION RULES
When generating code, you MUST:

1. **Follow folder structure** - Place files in correct directories
2. **Use API layer** - Never put Supabase calls in components
3. **Type everything** - All functions, props, and variables must be typed
4. **Use shadcn/ui** - Import UI components from `@/components/ui/*`
5. **Use Zod validation** - Create schemas for all form inputs and API requests
6. **Keep it minimal** - Don't add extra libraries or files unless asked
7. **Follow naming conventions** - camelCase for variables, PascalCase for components
8. **Use absolute imports** - `@/components/...` not `../components/...`
9. **Add error handling** - Wrap API calls in try/catch blocks
10. **Keep components clean** - Extract logic into hooks or utils
11. **Add TypeScript interfaces** - Define types for all data structures

## EXAMPLES OF GOOD PATTERNS

### Zod Schema with API Function
```ts
// src/schemas/transaction.ts
import { z } from "zod";

export const CreateTransactionSchema = z.object({
  amount: z.number().positive(),
  description: z.string().min(1).max(255),
  category: z.string().min(1),
  type: z.enum(['income', 'expense']),
  date: z.string().datetime(),
});

export type CreateTransactionRequest = z.infer<typeof CreateTransactionSchema>;

// src/api/transactions.ts
export async function createTransaction(data: CreateTransactionRequest): Promise<Transaction> {
  try {
    const { data: result, error } = await supabase
      .from("transactions")
      .insert(data)
      .select()
      .single();
    
    if (error) throw error;
    return result;
  } catch (error) {
    console.error("Failed to create transaction:", error);
    throw new Error("Unable to create transaction");
  }
}
```

### Form with Zod Validation
```tsx
// src/components/TransactionForm.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { CreateTransactionSchema, CreateTransactionRequest } from "@/schemas/transaction";

export function TransactionForm() {
  const form = useForm<CreateTransactionRequest>({
    resolver: zodResolver(CreateTransactionSchema),
    defaultValues: {
      amount: 0,
      description: "",
      category: "",
      type: "expense",
      date: new Date().toISOString(),
    },
  });

  const onSubmit = async (data: CreateTransactionRequest) => {
    try {
      await createTransaction(data);
      form.reset();
    } catch (error) {
      console.error("Failed to create transaction:", error);
    }
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* form fields */}
    </form>
  );
}
```

## ANTI-PATTERNS TO AVOID
- ❌ Supabase calls directly in components
- ❌ Inline styles instead of Tailwind classes
- ❌ Relative imports beyond parent directory
- ❌ Class components
- ❌ .then()/.catch() instead of async/await
- ❌ Hardcoded values instead of environment variables
- ❌ Large components (>200 lines)
- ❌ Business logic mixed with UI logic
- ❌ Untyped props or function parameters
- ❌ Form validation without Zod schemas
- ❌ API calls without proper error handling

## PERFORMANCE CONSIDERATIONS
- Use React.memo for expensive components
- Implement proper loading states
- Use Suspense boundaries where appropriate
- Optimize Supabase queries (select only needed columns)
- Implement proper error boundaries

Remember: These rules exist to help the team move fast while maintaining code quality. When in doubt, prioritize readability and maintainability over cleverness.